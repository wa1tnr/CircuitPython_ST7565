// Sat  6 Nov 16:48:12 UTC 2021

// Target: (likely, undocumented) Adafruit Feather M0 Express (checks made November 2021).

// Sun Feb 25 05:49:32 UTC 2018

// CALIPULLER   TALLOMEV    MONDIEUX    PALICA   CANFAW  ELKIND

// previous: 

// Wed Feb 21 20:32:59 UTC 2018

// The bitstream necessary to operate the ST7565 LCD is 100 percent
// identified.  There are no unknowns, wrt the data required to send
// good messages.  Timing is still unknown; a continuous bitstream
// seems to operate this LCD correctly (with no pauses programmed).

/*
ST7565 LCD library!  Copyright (C) 2010 Limor Fried, Adafruit Industries 
LGPL v2.1 
some of this code was written by <cstone@pobox.com> originally; it is in the public domain.
*/



#include <stdlib.h>
#include "Arduino.h"

// MOSI 29 SCK 30


int8_t sid  = 29;
// 11;
// int8_t sclk = 10;
int8_t sclk = 30;

int8_t a0   = 9;
int8_t rst  = 6;
int8_t cs   = 5;



uint8_t lcd_buffer[64] = { // max: 1024
  0xFC,  0x2, 0x1C,    0x2, 0xFC, 0x0,    // W
  0x3E, 0x48, 0x88,   0x48, 0x3E, 0x0,    // A
   0x0, 0x42, 0xFE,    0x2,  0x0, 0x0,    // 1
  0xC0, 0x80, 0xFE,   0x80, 0xC0, 0x0,    // T
  0xFE, 0x20, 0x10,    0x8, 0xFE, 0x0,    // N
  0xFE, 0x90, 0x98,   0x94, 0x62, 0x0,    // R
  0x10, 0x10, 0x10,   0x10, 0x10, 0x0,    // dash
  0x82, 0x84, 0x88,   0x90, 0xE0, 0x0,    // 7
 }; // okay to specify a short initializer list



void spiwrite(uint8_t c) {
    int8_t i;
    for (i=7; i>=0; i--) {
        digitalWrite(sclk, LOW);
        Serial.print("L");
        if (c &  (1 <<  (i)) ) { digitalWrite(sid, HIGH); Serial.print("1"); }

        else { digitalWrite(sid, LOW); Serial.print("0"); }

        digitalWrite(sclk, HIGH);
        Serial.print("H");
    }
}


void comm_out(uint8_t c) {
  digitalWrite(a0, LOW);
  Serial.print("aL");
  spiwrite(c);
}


void data_out(uint8_t c) {
  digitalWrite(a0, HIGH);
  Serial.print("aH");
  spiwrite(c);
}

int spaces = 38;

void lead_spaces(void) {
    for (int i=0; i< spaces; i++) {
        data_out(0x0);
    }
}

void draw_words(void) {
    for (int i=0; i<(6*8); i++) {
        data_out(lcd_buffer[i]);
    }
}

void dshow(void) {
    comm_out(0x10 | 0); // column, upper
    comm_out(0x00 | 0); // column, lower
    comm_out(0xb0 | 0); // pages: 3 2 1 0 7 6 5 4  top to bottom
    comm_out(0xe0);
    lead_spaces();
    draw_words();
}



// erase LCD
#define ERASED_TO    0x00  // may want another value to draw some horizontal lines
#define ERASED_TO_FF 0xff

void eshow(void) { // fill all pixels 0x00
    for (int i = 0; i<8; i++) {
        comm_out(0x10 | 0); // column upper
        comm_out(0x00 | 0); // column lower
        comm_out(0xb0 | i);
        comm_out(0xe0);
        for (int j=0; j<129; j++) {
            data_out(ERASED_TO);
        }
    }
}



void fshow(void) { // fill all pixels 0xff
    for (int i = 0; i<8; i++) {
        comm_out(0x10 | 0);
        comm_out(0x00 | 0);
        comm_out(0xb0 | i);
        comm_out(0xe0);
        for (int j=0; j<129; j++) {
            data_out(ERASED_TO_FF);
        }
    }
}



#define BACKLIGHT_LED A4

void init_backlight(void) {
  pinMode(BACKLIGHT_LED, OUTPUT);
  digitalWrite(BACKLIGHT_LED, HIGH);
}


void init_lcd(void) {
  pinMode(sid,  OUTPUT);
  pinMode(sclk, OUTPUT);
  pinMode(a0,   OUTPUT);
  pinMode(rst,  OUTPUT);
  pinMode(cs,   OUTPUT); // low by default

  digitalWrite(rst, HIGH); // toggling rst was unnecessary

  comm_out(0xa3); // required.

  /* power circuits */
  comm_out(0x28 | 0x4);
  comm_out(0x28 | 0x6);
  comm_out(0x28 | 0x7);
  comm_out(0x20 | 0x6);

  comm_out(0xaf); // required.

  // comm_out(0xa7); // reverse video

  /* improved contrast */
  comm_out(0x81); // reference voltage and follow-on byte (2-bytes):
  comm_out(0x00 | (0x1d & 0x3f));
}


void setup()   {                
  Serial.begin(38400);
  while (!Serial); // hold
  Serial.println("Delay..");
  delay(3000); // three second debug lead time
  Serial.println("Begin.");
  init_backlight();

  init_lcd();

  // erase or fill LCD
  // fshow();
  // eshow();

  // now draw something interesting:
  dshow();
  Serial.println("\r\nEND.");
}

void loop()                     
{}




 /*

uint8_t glyphs[511] = { 0x0, 0x0,
   0x0,  0x0,  0x0,  0x0,  0x0, 0x0,   // spc
   0x0,  0x0, 0xFA,  0x0,  0x0, 0x0,   // !

   0x0, 0xE0,  0x0, 0xE0,  0x0, 0x0,   // "
  0x28, 0xFE, 0x28, 0xFE, 0x28, 0x0,   // #
  0x24, 0x54, 0xFE, 0x54, 0x48, 0x0,   // $
  0xC4, 0xC8, 0x10, 0x26, 0x46, 0x0,   // %
  0x6C, 0x92, 0x6A,  0x4,  0xA, 0x0,   // &

   0x0, 0x10, 0xE0, 0xC0,  0x0, 0x0,    // '  // LINE 40
   0x0, 0x38, 0x44, 0x82,  0x0, 0x0,    // (
   0x0, 0x82, 0x44, 0x38,  0x0, 0x0,    // )
  0x54, 0x38, 0xFE, 0x38, 0x54, 0x0,    // *
  0x10, 0x10, 0x7C, 0x10, 0x10, 0x0,    // +

   0x0,  0x1,  0xE,  0xC,  0x0, 0x0,    // comma
  0x10, 0x10, 0x10, 0x10, 0x10, 0x0,    // dash
   0x0,  0x0,  0x6,  0x6,  0x0, 0x0,    // dot
   0x4,  0x8, 0x10, 0x20, 0x40, 0x0,    // slash

  0x7C, 0x8A, 0x92, 0xA2, 0x7C, 0x0,    // 0
   0x0, 0x42, 0xFE,  0x2,  0x0, 0x0,    // 1  // LINE 50
  0x4E, 0x92, 0x92, 0x92, 0x62, 0x0,    // 2
  0x84, 0x82, 0x92, 0xB2, 0xCC, 0x0,    // 3
  0x18, 0x28, 0x48, 0xFE,  0x8, 0x0,    // 4

  0xE4, 0xA2, 0xA2, 0xA2, 0x9C, 0x0,    // 5
  0x3C, 0x52, 0x92, 0x92, 0x8C, 0x0,    // 6
  0x82, 0x84, 0x88, 0x90, 0xE0, 0x0,    // 7
  0x6C, 0x92, 0x92, 0x92, 0x6C, 0x0,    // 8
  0x62, 0x92, 0x92, 0x94, 0x78, 0x0,    // 9

   0x0,  0x0, 0x28,  0x0,  0x0, 0x0,    // :
   0x0,  0x2, 0x2C,  0x0,  0x0, 0x0,    // ;    // LINE 60
   0x0, 0x10, 0x28, 0x44, 0x82, 0x0,    // <
  0x28, 0x28, 0x28, 0x28, 0x28, 0x0,    // =
   0x0, 0x82, 0x44, 0x28, 0x10, 0x0,    // >


  0x40, 0x80, 0x9A, 0x90, 0x60, 0x0,    // ?
  0x7C, 0x82, 0xBA, 0x9A, 0x72, 0x0,    // @
  0x3E, 0x48, 0x88, 0x48, 0x3E, 0x0,    // A

  0xFE, 0x92, 0x92, 0x92, 0x6C, 0x0,    // B
  0x7C, 0x82, 0x82, 0x82, 0x44, 0x0,    // C

  0xFE, 0x82, 0x82, 0x82, 0x7C, 0x0,    // D
  0xFE, 0x92, 0x92, 0x92, 0x82, 0x0,    // E    // LINE 70
  0xFE, 0x90, 0x90, 0x90, 0x80, 0x0,    // F
  0x7C, 0x82, 0x82, 0x8A, 0xCE, 0x0,    // G

  0xFE, 0x10, 0x10, 0x10, 0xFE, 0x0,    // H
   0x0, 0x82, 0xFE, 0x82,  0x0, 0x0,    // I
   0x4,  0x2, 0x82, 0xFC, 0x80, 0x0,    // J
  0xFE, 0x10, 0x28, 0x44, 0x82, 0x0,    // K
  0xFE,  0x2,  0x2,  0x2,  0x2, 0x0,    // L
  0xFE, 0x40, 0x38, 0x40, 0xFE, 0x0,    // M
  0xFE, 0x20, 0x10,  0x8, 0xFE, 0x0,    // N

  0x7C, 0x82, 0x82, 0x82, 0x7C, 0x0,    // O    // LINE 80
  0xFE, 0x90, 0x90, 0x90, 0x60, 0x0,    // P
  0x7C, 0x82, 0x8A, 0x84, 0x7A, 0x0,    // Q
  0xFE, 0x90, 0x98, 0x94, 0x62, 0x0,    // R
  0x64, 0x92, 0x92, 0x92, 0x4C, 0x0,    // S
  0xC0, 0x80, 0xFE, 0x80, 0xC0, 0x0,    // T
  0xFC,  0x2,  0x2,  0x2, 0xFC, 0x0,    // U
  0xF8,  0x4,  0x2,  0x4, 0xF8, 0x0,    // V
  0xFC,  0x2, 0x1C,  0x2, 0xFC, 0x0,    // W
  0xC6, 0x28, 0x10, 0x28, 0xC6, 0x0,    // X
  0xC0, 0x20, 0x1E, 0x20, 0xC0, 0x0,    // Y    // LINE 90
  0x86, 0x9A, 0x92, 0xB2, 0xC2, 0x0,    // Z 
};

 */


